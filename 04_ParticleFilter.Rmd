---
title: "04_ParticleFilter"
author: "Cam Reimer"
date: "4/26/2021"
output: html_document
---
```{r}
## Package check and load

#install.packages("tidyverse")
#install.packages("readr")
library(tidyverse)
library(readr)
library(rjags)
library(rnoaa)
library(daymetr)
library(ecoforecastR)
#source("/Users/niabartolucci/Dropbox/My Mac (Niaâ€™s MacBook Pro)/Desktop/Classes Spring 2021/Ecological Forecasting/EF_Activities/ecoforecastR/R/utils.R")

#remotes::install_github("EcoForecast/ecoforecastR",force=TRUE)
```

```{r}
# If you need run data download
###source('01A_Targetdownload.R')

# definition for PATH
basePath <- getwd() 
graphPath <- paste0(basePath,"/graph/")
dataPath <- paste0(basePath,"/data/")

# load the data file [30 min Target data]
loadFilename <- sprintf("%s.Rdata","Target_30min")
loadFilename <- paste(dataPath, loadFilename, sep="", collapse = NULL)
load(file = loadFilename)

Target_30min_KONZ = subset(Target_30min, siteID == 'KONZ' & time >= as.POSIXct('2020-03-01 00:00', tz="UTC") & 
                                                                time < as.POSIXct('2021-03-01 00:00', tz="UTC"))
time_KONZ = Target_30min_KONZ$time
```

```{r}
## Forward Simulation Time Setup
Nmc = 1000         ## set number of Monte Carlo draws
N.cols <- c("red","green","blue") ## set colors
trans <- 0.8       ## set transparancy
time = 1:length(time_KONZ)+1681    ## total time (1yr + 35 days)
time1 = 1:length(time_KONZ)       ## calibration period
time2 = (length(time_KONZ)+1):(length(time_KONZ)+1681)   ## forecast period
timeN_predict = length(time2)
tmp = matrix(0,1,length(time))
#ylim = c(-500,700)
```

```{r}
#### TO BE UPDATED

### I think the updating of IC's needs to happen outside of the function because it will not update the environment outside of the function with the new variables. 

### Also, I would like to find a better way to keep track of all 23 inputs because this looks messy. Not to mention that I have to be able to match all of these to outputs from the mcmc output.


forecastN <- function(IC_NEE,IC_LE,IC_VSWC,beta_NEE,beta_LE,beta_VSWC,beta_NL,beta_NV,beta_LV,beta_LN,beta_VN,beta_VL,
                        beta_NEEI,beta_LEI,beta_VSWCI,beta_sw1,beta_sw2,beta_lw,beta_temp,beta_precip,sw,lw,temp,precip
                        ,Q=0,n=Nmc){
  NEE <- matrix(NA,n,timeN_predict)  ## storage
  LE <- matrix(NA,n,timeN_predict)
  VSWC <- matrix(NA,n,timeN_predict)
  Nprev_NEE <- IC_NEE           ## initialize
  Nprev_LE <- IC_LE
  Nprev_VSWC <- IC_VSWC
  for(t in 1:timeN_predict){
    mu_nee = (1+beta_NEE)*Nprev_NEE+beta_NEEI+beta_NL*Nprev_LE+beta_NV*Nprev_VSWC+beta_sw1*sw +beta_temp*temp
    mu_le = (1+beta_LE)*Nprev_LE+beta_LEI+beta_LN*Nprev_NEE+beta_LV*Nprev_VSWC+beta_sw2*sw +beta_lw*lw
    mu_vswc = (1+beta_VSWC)*Nprev_VSWC+beta_VSWCI+beta_VN*Nprev_NEE+beta_VL*Nprev_LE+beta_precip*precip
    NEE[,t] <- rnorm(n,mu_nee,Q)                         ## predict next step
    LE[,t] <- rnorm(n,mu_le,Q)
    VSWC[,t] <- rnorm(n,mu_vswc,Q)
    Nprev_NEE <- NEE[,t]                                 ## update IC
    Nprev_LE <- LE[,t]
    Nprev_VSWC <- VSWC[,t]
  }
 # N <- list(NEE_predict=NEE, LE_predict=LE, VSWC_predict=VSWC)
 # return(N)
  return(cbind(NEE=NEE, LE=LE, VSWC=VSWC))
}
```

```{r}
#Initial Forecast
X = X.orig       ## initial condition
ne = 50     #update to 500?
nt = 35 * 48                           ## 35 days of 30min; production run should be nrow(inputs) *********
output = array(0.0, c(nt, ne, 3))     ## output storage [time step,ensembles,variables]

## foreward ensemble simulation
for(t in 1:nt){
  output[t, , ] <- SSE(X, params, inputs[t, ])  ## run model, save output
  X <- output[t, , 1:3]                          ## set most recent prediction to be the next IC
  if((t %% 336) == 0) print(t / 336)             ## counter: weeks elapsed (7*48 = 1 week)
}

output[is.nan(output)] = 0
output[is.infinite(output)] = 0
output.ensemble = output                         ## save original ensemble projection

## average the output to daily
bin = 86400 / timestep          ## seconds per day / timestep = number of timesteps per day
out.daily = array(0.0, c(ceiling(nt/bin), ne, 12))  ## [day, ensemble, variables]
for(i in 1:12){                 ## loop over each variable
  print(i)
  out.daily[,,i] <- apply(output[,,i],2, ctapply, rep(1:365,each=bin)[1:nt], mean)
}

## Basic time-series visualizations
varnames <- c("Bleaf","Bwood","BSOM","LAI","GPP","NEP","Ra",
              "NPPw","NPPl","Rh","litterfall","mortality")
units <- c("Mg/ha","Mg/ha","Mg/ha","m2/m2","umol/m2/sec","umol/m2/sec",
           "umol/m2/sec","umol/m2/sec","umol/m2/sec","umol/m2/sec",
           "Mg/ha/timestep","Mg/ha/timestep")

for(i in 1:12){  ## loop over variables
  ci = apply(out.daily[, , i], 1, quantile, c(0.025, 0.5, 0.975))   ## calculate CI over ensemble members
  plot(ci[2, ], main = varnames[i], 
       xlab = "time", ylab = units[i], type='l',ylim  =range(ci))
  ciEnvelope(1:ncol(ci), ci[1, ], ci[3, ], col = col.alpha("lightGrey", 0.5)) ## plot interval
  lines(ci[2, ])                                                              ## plot median
}
```